<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="博客 前端 前端开发">
<meta property="og:type" content="website">
<meta property="og:title" content="乌斯怀亚-世界以南">
<meta property="og:url" content="http://ifun.work/page/2/index.html">
<meta property="og:site_name" content="乌斯怀亚-世界以南">
<meta property="og:description" content="博客 前端 前端开发">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="乌斯怀亚-世界以南">
<meta name="twitter:description" content="博客 前端 前端开发">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ifun.work/page/2/"/>





  <title>乌斯怀亚-世界以南</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">乌斯怀亚-世界以南</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">weihome的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifun.work/2017/04/10/You-don-t-know-JS-this和对象原型-笔记（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weihome">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌斯怀亚-世界以南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/10/You-don-t-know-JS-this和对象原型-笔记（三）/" itemprop="url">You don't know JS:this和对象原型 笔记（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-10T20:25:52+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><ul>
<li><p>字面形式</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="comment">//字面声明一次性添加一个或多个键/值对</span></span><br><span class="line">    key: value</span><br><span class="line">    <span class="comment">// ...      </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造形式</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 构造形式，只能一个一个地添加属性。</span></span><br><span class="line">myObj.key = value;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>es5的中主要类型:</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>object</li>
</ul>
<p>简单基本类型 （string，number，boolean，null，和undefined）不是object, <code>typeof null</code>返回字符串”object”属于语言bug。</p>
<p>存在几种特殊的对象子类型，称之为复杂基本类型，比如 <code>function</code> 和 <code>array</code>。</p>
<h3 id="内建对象"><a href="#内建对象" class="headerlink" title="内建对象"></a>内建对象</h3><ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<p>在JS中，它们仅仅是内建的函数，可以被用作构造器（和new操作符一起调用），其结果是一个新构建的相应子类型的对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPrimitive = <span class="string">"I am a string"</span>;</span><br><span class="line"><span class="keyword">typeof</span> strPrimitive;                            <span class="comment">// "string"</span></span><br><span class="line">strPrimitive <span class="keyword">instanceof</span> <span class="built_in">String</span>;                    <span class="comment">// false 基本简单类型不是对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strObject = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">"I am a string"</span> );</span><br><span class="line"><span class="keyword">typeof</span> strObject;                                 <span class="comment">// "object"</span></span><br><span class="line">strObject <span class="keyword">instanceof</span> <span class="built_in">String</span>;                    <span class="comment">// true     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 考察 object 子类型</span></span><br><span class="line"><span class="comment">// 可用来判断类型</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( strObject );    <span class="comment">// [object String]</span></span><br></pre></td></tr></table></figure>
<p>tip： </p>
<blockquote>
<p>基本类型值不是一个对象，它是一个不可变的基本字面值。为了对它进行操作，在必要的时候会自动地将基本类型转换为对象类型，所以几乎从不需要明确地创建对象。</p>
</blockquote>
<h3 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.a;        <span class="comment">// 2 “属性（property）”访问, `.`操作符后面需要一个标识符（Identifier）兼容的属性名</span></span><br><span class="line"></span><br><span class="line">myObject[<span class="string">"a"</span>];    <span class="comment">// 2 “键（key）”访问, 基本可以接收任何字符串作为属性名,可以用来动态地组建字符串的值</span></span><br></pre></td></tr></table></figure>
<p>属性名总是字符串。如果使用字符串以外（基本）类型的值，它会首先被转换为字符串。</p>
<p>es6的计算型属性名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prefix = <span class="string">"foo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    [prefix + <span class="string">"bar"</span>]: <span class="string">"hello"</span>,</span><br><span class="line">    [prefix + <span class="string">"baz"</span>]: <span class="string">"world"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject[<span class="string">"foobar"</span>]; <span class="comment">// hello</span></span><br><span class="line">myObject[<span class="string">"foobaz"</span>]; <span class="comment">// world</span></span><br></pre></td></tr></table></figure>
<p>tips: </p>
<p>访问的属性如果是一个函数，不意味着这个函数属于这个对象，不是方法访问而是引用这个函数。</p>
<p>如果你试图在一个数组上添加属性，但是属性名 看起来 像一个数字，那么最终它会成为一个数字索引（也就是改变了数组的内容）。</p>
<p>JSON安全的对象简单的复制：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringify( someObj ) );</span><br></pre></td></tr></table></figure></p>
<h4 id="属性描述符（Property-Descriptors）"><a href="#属性描述符（Property-Descriptors）" class="headerlink" title="属性描述符（Property Descriptors）"></a>属性描述符（Property Descriptors）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor( myObject, <span class="string">"a"</span> ); <span class="comment">// 获取属性描述符</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    value: 2,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123; <span class="comment">// 定义属性描述符</span></span><br><span class="line">    value: <span class="number">2</span>,                           <span class="comment">// 属性的值</span></span><br><span class="line">    writable: <span class="literal">true</span>,                     <span class="comment">// 可写性，如果为false，对value的修改将悄无声息地失败或得到一个TypeError错误</span></span><br><span class="line">    configurable: <span class="literal">true</span>,                 <span class="comment">// 可配置性，设置为false是一个单向操作，不可撤销！</span></span><br><span class="line">                                        <span class="comment">// 设置为false后，writeable可以由ture变为false，但不能由false变为ture；delete移除属性失效；</span></span><br><span class="line">    enumerable: <span class="literal">true</span>                    <span class="comment">// 可枚举性，如果为false，在for..in循环中不会出现，不包括in操作符</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 不可变性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> - 对象常量：writable:false + configurable:false，创建了一个作为对象属性的常量（不能被改变，重定义或删除）</span></span><br><span class="line"><span class="string"> - 防止扩展：防止一个对象被添加新的属性，但另一方面保留其他既存的对象属性：Object.preventExtensions(..)</span></span><br><span class="line"><span class="string"> - 封印：Object.seal(..)：Object.preventExtensions(..) + configurable:false</span></span><br><span class="line"><span class="string"> - 冻结： Object.seal(..) + writable:false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### [[Get]]和[[Put]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[[Get]]：获取属性，首先检查对象，寻找被请求的属性，如果找到，就返回相应的值。如果没找到，会遍历[[Prototype]]链向上寻找。最终也没找到，返回undefined。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[[Put]]：设置属性，如果属性存在，将会大致检查：这个属性是访问器描述符吗？如果是，而且是setter，就调用setter。这个属性是writable为false数据描述符吗？如果是，在非strict mode下无声地失败，或者在strict mode下抛出TypeError。否则，像平常一样设置既存属性的值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 访问器属性：Getters 与 Setters</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// 字面法</span></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    <span class="comment">// 为`a`定义getter</span></span><br><span class="line">    get a() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为`a`定义setter</span></span><br><span class="line">    set a(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>._a_ = val * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defineProperty法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(</span><br><span class="line">    myObject,   <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="string">"b"</span>,        <span class="comment">// 属性名</span></span><br><span class="line">    &#123;           <span class="comment">// 描述符</span></span><br><span class="line">        <span class="comment">// 为`b`定义getter</span></span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._a_&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保`b`作为对象属性出现</span></span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">2</span>;</span><br><span class="line">myObject.a; <span class="comment">// 4</span></span><br><span class="line">myObject.b; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in操作符会检查属性是否存在于对象 中，或者是否存在于[[Prototype]]链对象遍历的更高层中</span></span><br><span class="line">(<span class="string">"a"</span> <span class="keyword">in</span> myObject);                <span class="comment">// true</span></span><br><span class="line">(<span class="string">"b"</span> <span class="keyword">in</span> myObject);                <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//hasOwnProperty(..) 仅仅 检查myObject是否拥有属性，但 不会 查询[[Prototype]]链</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">"a"</span> );    <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">"b"</span> );    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更加健壮的查询</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.call(myObject,<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(</span><br><span class="line">    myObject,</span><br><span class="line">    <span class="string">"a"</span>,</span><br><span class="line">    <span class="comment">// 使`a`可枚举</span></span><br><span class="line">    &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="number">2</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(</span><br><span class="line">    myObject,</span><br><span class="line">    <span class="string">"b"</span>,</span><br><span class="line">    <span class="comment">// 使`b`不可枚举</span></span><br><span class="line">    &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">myObject.b; <span class="comment">// 3</span></span><br><span class="line">(<span class="string">"b"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">"b"</span> ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性b存在，可访问，但是不可枚举，所以不会出现在 for..in..操作符的结果中：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> myObject) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( k, myObject[k] ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "a" 2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以区分可枚举和不可枚举属性的方法：</span></span><br><span class="line">myObject.propertyIsEnumerable( <span class="string">"a"</span> ); <span class="comment">// true</span></span><br><span class="line">myObject.propertyIsEnumerable( <span class="string">"b"</span> ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.keys(..)返回一个所有可枚举属性的数组：</span></span><br><span class="line"><span class="built_in">Object</span>.keys( myObject ); <span class="comment">// ["a"] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.getOwnPropertyNames(..)返回一个所有属性的数组，不论能不能枚举：</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames( myObject ); <span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure>
<p>in和hasOwnProperty(..)区别于它们是否查询[[Prototype]]链，而Object.keys(..)和Object.getOwnPropertyNames(..)都只考察直接给定的对象。</p>
<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><ul>
<li>对象的字面形式和构造形式，各自的特点</li>
<li>js的基本类型，对象的子类型，内建对象</li>
<li>属性访问的机制，<code>.</code>和<code>[]</code>形式，当前对象没找到的话沿着[[Prototype]]链继续找，返回值（属性的值或undefined）</li>
<li>属性描述符，如何通过定义属性描述符来控制对象，几种不同等级的不可变性</li>
<li>访问器属性，定义访问器属性</li>
<li>判断属性是否存在，是否可枚举的方法</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifun.work/2017/04/09/You-don-t-know-JS-this和对象原型-笔记（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weihome">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌斯怀亚-世界以南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/09/You-don-t-know-JS-this和对象原型-笔记（二）/" itemprop="url">You don't know JS:this和对象原型 笔记（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-09T14:30:31+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="彻底理解this"><a href="#彻底理解this" class="headerlink" title="彻底理解this"></a>彻底理解this</h2><h3 id="调用点（Call-site）"><a href="#调用点（Call-site）" class="headerlink" title="调用点（Call-site）"></a>调用点（Call-site）</h3><p>调用点：函数在代码中被调用的位置（不是被声明的位置）。</p>
<p>查找调用点：</p>
<ul>
<li><p>找到一个函数是在哪里被调用的</p>
</li>
<li><p>调用点就位于调用栈中当前执行函数之前的调用</p>
</li>
</ul>
<p>展示一下调用栈和调用点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈是: `baz`</span></span><br><span class="line">    <span class="comment">// 我们的调用点是global scope（全局作用域）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"baz"</span> );</span><br><span class="line">    bar(); <span class="comment">// &lt;-- `bar`的调用点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈是: `baz` -&gt; `bar`</span></span><br><span class="line">    <span class="comment">// 我们的调用点位于`baz`</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"bar"</span> );</span><br><span class="line">    foo(); <span class="comment">// &lt;-- `foo`的调用点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈是: `baz` -&gt; `bar` -&gt; `foo`</span></span><br><span class="line">    <span class="comment">// 我们的调用点位于`bar`</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"foo"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// &lt;-- `baz`的调用点</span></span><br></pre></td></tr></table></figure>
<p>tip: </p>
<blockquote>
<p>在想要查询this的函数中打断点，然后使用浏览器开发者工具取得调用栈，之后从上向下找到第二个记录，那就是真正的调用点。</p>
</blockquote>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>调用点根据四个规则决定在函数执行期间this指向哪里。</p>
<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>第一种规则来源于函数调用的最常见的情况：独立函数调用，可以认为是默认规则。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// "use strict"; 严格模式下，this成为undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 2 函数foo的调用点，位于全局作用域，this指向全局作用域</span></span><br></pre></td></tr></table></figure>
<p>如果foo函数在严格模式下，默认绑定的全局对象是非法的。</p>
<h4 id="隐含绑定"><a href="#隐含绑定" class="headerlink" title="隐含绑定"></a>隐含绑定</h4><p>调用点有一个环境对象（context object）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    obj: obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 1 调用点使用obj环境来引用函数，obj调用函数没，this指向obj对象</span></span><br><span class="line">obj2.obj.foo(); <span class="comment">// 1 只有对象属性引用链的最后一层是影响调用点的。</span></span><br></pre></td></tr></table></figure>
<p>当一个方法引用存在一个环境对象时，这个对象被用于这个函数调用的this绑定。因为obj是foo()调用的this，所以this.a就是obj.a的同义词。</p>
<h5 id="隐含丢失"><a href="#隐含丢失" class="headerlink" title="隐含丢失"></a>隐含丢失</h5><p>当一个隐含绑定丢失了它的绑定，这通常意味着它会退回到默认绑定， 根据strict mode的状态，结果不是全局对象就是undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数引用！并不是函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a`也是一个全局对象的属性</span></span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// "oops, global" 隐含绑定丢失了他的绑定，退回默认绑定，foo函数的this不是undefined就是全局对象</span></span><br></pre></td></tr></table></figure>
<h4 id="明确绑定"><a href="#明确绑定" class="headerlink" title="明确绑定"></a>明确绑定</h4><p>使用访问call(..)和apply(..)，它们接收的第一个参数都是一个用于this的对象，之后使用这个指定的this来调用函数。因为你已经直接指明你想让this是什么，所以我们称这种方式为明确绑定（explicit binding)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); <span class="comment">// 2 明确绑定obj来调用函数，this指向obj对象</span></span><br></pre></td></tr></table></figure>
<p>如果你传递一个简单原始类型值（string，boolean，或 number类型）作为this绑定，那么这个原始类型值会被包装在它的对象类型中（分别是new String(..)，new Boolean(..)，或new Number(..)）。这通常称为“boxing（封箱）”。就this绑定的角度讲，call(..)和apply(..)是完全一样的。</p>
<h5 id="明确绑定中的硬绑定"><a href="#明确绑定中的硬绑定" class="headerlink" title="明确绑定中的硬绑定"></a>明确绑定中的硬绑定</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 2</span></span><br><span class="line">setTimeout( bar, <span class="number">100</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `bar`将`foo`的`this`硬绑定到`obj`</span></span><br><span class="line"><span class="comment">// 所以它不可以被覆盖</span></span><br><span class="line">bar.call( <span class="built_in">window</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>无论怎样调用函数bar，它总是手动使用obj调用foo。这种绑定即明确又坚定，所以我们称之为 硬绑定（hard binding）</p>
<p>由于 硬绑定 是一个如此常用的模式，它已作为ES5的内建工具提供：Function.prototype.bind，像这样使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( obj ); <span class="comment">// 使用obj来调用foo函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>在JS中，构造器仅仅是一个函数，在被new来调用时改变了行为。</p>
<p>当在函数前面被加入new调用时，也就是构造器调用时，下面这些事情会自动完成：</p>
<ol>
<li>创建一个全新的对象</li>
<li>这个对象接入原型链</li>
<li>这个对象被设置为函数调用的this绑定</li>
<li>除非函数返回一个它自己的其他对象，这个被new调用的函数将自动返回这个新构建的对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo( <span class="number">2</span> );    <span class="comment">// foo被new调用，完成构造器调用发生的四个步骤</span></span><br><span class="line"><span class="built_in">console</span>.log( bar.a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="判定-this"><a href="#判定-this" class="headerlink" title="判定 this"></a>判定 this</h3><p>this的四个绑定规则分别是：</p>
<ul>
<li>默认绑定</li>
<li>隐含绑定</li>
<li>明确绑定</li>
<li>new绑定</li>
</ul>
<p>运用这四种规则判定this指向时，可能会出现几种情况都适用的情况，便会按照优先顺序从函数调用的调用点来判定，然后在第一个规则适用的地方停下。</p>
<ol>
<li>函数是和new一起被调用的吗（new绑定）？如果是，this就是新构建的对象。<br> var bar = new foo()；</li>
<li>函数是用call或apply被调用（明确绑定），甚至是隐藏在bind 硬绑定 之中吗？如果是，this就是明确指定的对象。<br> var bar = foo.call( obj2 )；</li>
<li>函数是用环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this就是那个环境对象。<br> var bar = obj1.foo()；</li>
<li>否则，使用默认的this（默认绑定）。如果在strict mode下，就是undefined，否则是global对象。<br> foo()；</li>
</ol>
<p>以上，几乎就是理解对于普通的函数调用来说的this绑定规则所需的全部。</p>
<h3 id="绑定的特例"><a href="#绑定的特例" class="headerlink" title="绑定的特例"></a>绑定的特例</h3><h4 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h4><p>如果你传递null或undefined作为call，apply或bind的this绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。</p>
<p>使用apply()来将一个数组散开，从而作为函数调用的参数，或者使用bind(..)进行柯里化，会故意传递null，使this适用默认绑定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组散开作为参数</span></span><br><span class="line">foo.apply( <span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>] ); <span class="comment">// a:2, b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用`bind(..)`进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( <span class="literal">null</span>, <span class="number">2</span> );</span><br><span class="line">bar( <span class="number">3</span> ); <span class="comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure>
<p>然而这种做法带来潜在的隐患，更好的做法是传递一个特别建立好的对象来代替null：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create(null)和&#123;&#125;很相似，但是没有Object.prototype的委托，所以它比&#123;&#125;“空得更彻底”。</span></span><br><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create( <span class="literal">null</span> );</span><br></pre></td></tr></table></figure>
<h4 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h4><p>创建对函数的“间接引用（indirect reference）”，在那样的情况下，当那个函数引用被调用时，默认绑定规则也会适用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo &#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); <span class="comment">// 3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2 隐含的丢失，适用默认绑定</span></span><br></pre></td></tr></table></figure>
<h4 id="词法this"><a href="#词法this" class="headerlink" title="词法this"></a>词法this</h4><p>ES6引入了一种不适用于这些规则特殊的函数：箭头函数（arrow-function）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个arrow function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的`this`是`foo()`被调用时的词法作用域引用</span></span><br><span class="line">        <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); <span class="comment">// 2, 不是3! bar（被返回的箭头函数的引用）也将this绑定到obj1，箭头函数的this不会被覆盖</span></span><br></pre></td></tr></table></figure>
<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><ul>
<li>为执行中的函数判定this绑定需要找到这个函数的直接调用点。找到之后，4种规则以优先顺序施用于调用点：</li>
</ul>
<ol>
<li>被new调用？使用新构建的对象。</li>
<li>被call或apply（或 bind）调用？使用指定的对象。</li>
<li>被持有调用的环境对象调用？使用那个环境对象。</li>
<li>默认：strict mode下是undefined，否则就是全局对象。</li>
</ol>
<ul>
<li>例外的情况<ul>
<li>被忽略的this，退回到默认绑定</li>
<li>间接引用，退回到默认绑定</li>
<li>ES6的箭头函数使用词法作用域来决定this绑定，采用函数调用的作用域作为this绑定。它们实质上是ES6之前的self = this代码的语法替代品。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifun.work/2017/04/08/You-don-t-know-JS-this和对象原型-笔记（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weihome">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌斯怀亚-世界以南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/08/You-don-t-know-JS-this和对象原型-笔记（一）/" itemprop="url">You don't know JS:this和对象原型 笔记（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-08T21:37:46+08:00">
                2017-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="this是什么？"><a href="#this是什么？" class="headerlink" title="this是什么？"></a>this是什么？</h2><h3 id="为什么用-this？"><a href="#为什么用-this？" class="headerlink" title="为什么用 this？"></a>为什么用 this？</h3><p>先看一段代码,使用this来使函数对多个<strong>环境对象</strong>进行复用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">"Hello, I'm "</span> + identify.call( <span class="keyword">this</span> );</span><br><span class="line">    <span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">    name: <span class="string">"Kyle"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">    name: <span class="string">"Reader"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">identify.call( me ); <span class="comment">// KYLE</span></span><br><span class="line">identify.call( you ); <span class="comment">// READER</span></span><br><span class="line"></span><br><span class="line">speak.call( me ); <span class="comment">// Hello, I'm KYLE</span></span><br><span class="line">speak.call( you ); <span class="comment">// Hello, I'm READER</span></span><br></pre></td></tr></table></figure>
<p>与使用this相反，可以明确地将环境对象传递给函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">"Hello, I'm "</span> + identify( context );</span><br><span class="line">    <span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify( you ); <span class="comment">// READER</span></span><br><span class="line">speak( me ); <span class="comment">// Hello, I'm KYLE</span></span><br></pre></td></tr></table></figure>
<h4 id="使用this的原因"><a href="#使用this的原因" class="headerlink" title="使用this的原因"></a>使用this的原因</h4><p>this机制提供了更优雅的方式来隐含地“传递”一个对象引用，导致更加干净的API设计和更容易的复用。</p>
<p>将执行环境作为一个明确参数传递，通常比传递this执行环境要乱。当我们探索对象和原型时，你将会看到一组可以自动引用恰当执行环境对象的函数是多么有用。</p>
<h3 id="对this的误解"><a href="#对this的误解" class="headerlink" title="对this的误解"></a>对this的误解</h3><h4 id="误解一：this指向它自己"><a href="#误解一：this指向它自己" class="headerlink" title="误解一：this指向它自己"></a>误解一：this指向它自己</h4><p>第一种常见的倾向是认为this指向函数自己。</p>
<p>考虑下面的代码，我们试图追踪函数(foo)被调用了多少次：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追踪`foo`被调用了多少次</span></span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo( i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `foo`被调用了多少次？</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 0 -- 如果this指向的是它自己，那么这里的count的值应该是 4</span></span><br></pre></td></tr></table></figure>
<p>如果要指向函数它自己，的确有其它的方法，比如使用词法作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追踪foo被调用了多少次</span></span><br><span class="line">    data.count++;</span><br><span class="line">    foo.count++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo( i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo被调用了多少次？</span></span><br><span class="line"><span class="built_in">console</span>.log( data.count ); <span class="comment">// 4</span></span><br><span class="line">onsole.log( foo.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>或者强迫this指向函数它自己：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追踪`foo`被调用了多少次</span></span><br><span class="line">    <span class="comment">// 注意：由于`foo`的被调用方式（见下方），`this`现在确实是`foo`</span></span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 `call(..)`，我们可以保证`this`指向函数对象(`foo`)</span></span><br><span class="line">        foo.call( foo, i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `foo`被调用了多少次？</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="误解二：this指向函数的词法作用域"><a href="#误解二：this指向函数的词法作用域" class="headerlink" title="误解二：this指向函数的词法作用域"></a>误解二：this指向函数的词法作用域</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.bar(); <span class="comment">// 碰巧可以工作，this此时指向全局作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a ); <span class="comment">// 试图使用this查询foo的词法作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="什么是this？"><a href="#什么是this？" class="headerlink" title="什么是this？"></a>什么是this？</h3><p>this不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。this绑定和函数声明的位置无关，反而和函数被调用的方式有关。</p>
<p>当一个函数被调用时，会建立一个活动记录，也称为执行环境。这个记录包含函数是从何处（call-stack）被调用的，函数是 如何 被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的this引用。</p>
<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><ul>
<li>this既不是函数自身的引用，也不是函数词法作用域的引用。</li>
<li>this实际上是在函数被调用时建立的一个绑定，它指向 什么 是完全由函数被调用的调用点来决定的。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifun.work/2017/04/06/You-don-t-know-JS-Scope-Closures-笔记（五）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weihome">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌斯怀亚-世界以南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/06/You-don-t-know-JS-Scope-Closures-笔记（五）/" itemprop="url">You don't know JS: Scope & Closures 笔记（五）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-06T22:06:12+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>闭包就是函数即使在它的词法作用域之外执行，也能够记住并访问它的词法作用域。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();<span class="comment">// 将bar赋值给baz</span></span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 执行bar，输出2。此时bar在它被声明的词法作用域（foo）外被执行，这就是闭包</span></span><br></pre></td></tr></table></figure>
<p>一般来说，当foo执行完后，它的作用域应该被回收，但是bar()拥有一个词法作用域闭包覆盖着foo()的内部作用域，闭包为了能使bar()在以后任意的时刻可以引用这个作用域而保持它的存在。bar()在它被编写时的词法作用域之外被调用。闭包使这个函数可以继续访问它在编写时被定义的词法作用域。</p>
<p>闭包使函数在被声明的作用域之外执行时仍可以访问被声明时的作用域，计时器，事件处理器，Ajax请求，跨窗口消息，web worker，或者任何其他的异步（或同步！）任务等等，当你传入一个回调函数，就已经在使用闭包了！</p>
<h3 id="IFFE是闭包么"><a href="#IFFE是闭包么" class="headerlink" title="IFFE是闭包么"></a>IFFE是闭包么</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>严格来说它不是在观察闭包。为什么？因为这个函数（就是我们这里命名为“IIFE”的那个）没有在它的词法作用域之外执行。它仍然在它被声明的相同作用域中（那个同时持有a的外围/全局作用域）被调用。a是通过普通的词法作用域查询找到的，不是通过真正的闭包。</p>
<h3 id="循环中的闭包"><a href="#循环中的闭包" class="headerlink" title="循环中的闭包"></a>循环中的闭包</h3><p>老生常谈：下面代码的输出结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 期望输出1、2、3、4、5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出了5个6。</p>
<blockquote>
<p>超时的回调函数都将在循环的完成之后立即运行。实际上，就计时器而言，即便在每次迭代中它是setTimeout(.., 0)，所有这些回调函数也都仍然是严格地在循环之后运行的，因此每次都打印6。</p>
</blockquote>
<p>这里还有更深的问题，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们都闭包在同一个共享的全局作用域上，所以，所有函数共享一个指向相同的i的引用。要解决这个问题，我们需要为循环的每次迭代都准备一个新的被闭包的作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用IFFE为每个循环创建新的作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log( i );</span><br><span class="line">        &#125;, i*<span class="number">1000</span> );</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而创建的作用域是空的，什么也没有。更进一步：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> j = i;     <span class="comment">// 为新的作用域添加了变量，并且将循环中的i的值赋给了它</span></span><br><span class="line">        setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log( j );</span><br><span class="line">        &#125;, j*<span class="number">1000</span> );</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变形</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log( j );</span><br><span class="line">        &#125;, j*<span class="number">1000</span> );</span><br><span class="line">    &#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到了想要的结果~</p>
<h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p>使用let将块变成了一个我们可以闭包的作用域:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i; <span class="comment">// 将循环中的i的值赋给块作用域中的j</span></span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( j );</span><br><span class="line">    &#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用let替换循环体中的var：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于for循环头部的let声明将不是只为循环声明一次，而是为每次迭代声明一次。并且，它将在每次后续的迭代中被上一次迭代末尾的值初始化。</p>
<h3 id="模块中使用的闭包"><a href="#模块中使用的闭包" class="headerlink" title="模块中使用的闭包"></a>模块中使用的闭包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( something );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = CoolModule(); <span class="comment">// 执行CoolModule函数后创建了一个模块</span></span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool 函数doSomething在被声明的作用域外执行</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>因为存在闭包，所以模块的api能够访问当初被声明的作用域。</p>
<p>行使模块模式有两个“必要条件”：</p>
<ul>
<li><p>必须有一个外部的外围函数，而且它必须至少被调用一次（每次创建一个新的模块实例）。</p>
</li>
<li><p>外围的函数必须至少返回一个内部函数，这样这个内部函数才拥有私有作用域的闭包，并且可以访问和/或修改这个私有状态。</p>
</li>
</ul>
<p>一个仅带有一个函数属性的对象不是真正的模块。从可观察的角度来说，一个从函数调用中返回的对象，仅带有数据属性而没有闭包的函数，也不是真正的模块。</p>
<h3 id="未来的模块"><a href="#未来的模块" class="headerlink" title="未来的模块"></a>未来的模块</h3><p>ES6中的模块：将一个文件视为一个独立的模块。每个模块可以导入其他的模块或者特定的API成员，也可以导出它们自己的公有API成员。基于函数的模块，API语义直到运行时才会被考虑。也就是，你实际上可以在运行时期间修改模块的API。跟基于函数的模块不同，es6的模块可以被编译器感知，在编译阶段就检查模块和其中的引用是否存在。在模块文件内部的内容被视为像是包围在一个作用域闭包中，就像早先看到的使用函数闭包的模块那样。关于ES6的模块系统还需要深入学习。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。</p>
<p>模块要求两个关键性质：</p>
<ul>
<li>一个被调用的外部包装函数，来创建外围作用域。</li>
<li>这个包装函数的返回值必须包含至少一个内部函数的引用，这个函数才拥有包装函数内部作用域的闭包。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifun.work/2017/04/05/You-don-t-know-JS-Scope-Closures-笔记（四）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weihome">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌斯怀亚-世界以南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/05/You-don-t-know-JS-Scope-Closures-笔记（四）/" itemprop="url">You don't know JS: Scope & Closures 笔记（四）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-05T22:31:39+08:00">
                2017-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>在一个作用域中声明的任何变量都附着在这个作用域上。</p>
<h3 id="声明和赋值：先有鸡还是先有蛋？"><a href="#声明和赋值：先有鸡还是先有蛋？" class="headerlink" title="声明和赋值：先有鸡还是先有蛋？"></a>声明和赋值：先有鸡还是先有蛋？</h3><p>有如下两段代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 输出undefined？输出的是 2</span></span><br></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );   <span class="comment">// 变量a在声明前被使用，抛出ReferenceError错误？ 输出的undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="编译器编译步骤"><a href="#编译器编译步骤" class="headerlink" title="编译器编译步骤"></a>编译器编译步骤</h3><p>如果有一个语句: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>JavaScript实际上认为这是两个语句：var a;和a = 2;。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在原处。</p>
<p>于是我们的第一个代码段应当被认为是这样被处理的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;            <span class="comment">// 编译阶段，声明</span></span><br><span class="line">a = <span class="number">2</span>;            <span class="comment">// 执行阶段，赋值  </span></span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>
<p>相似地，我们的第二个代码段实际上被处理为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;              <span class="comment">// 编译，声明</span></span><br><span class="line"><span class="built_in">console</span>.log( a );   <span class="comment">// 执行，RHS查询</span></span><br><span class="line">a = <span class="number">2</span>;              <span class="comment">// 执行，赋值</span></span><br></pre></td></tr></table></figure>
<p>在JS中，变量和函数声明被从它们在代码流中出现的位置“移动”到代码的顶端。这就产生了“提升”。换句话说，先有蛋（声明），后有鸡（赋值）。而且提升是以作用域为单位的，函数表达式也不会被提升。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;       <span class="comment">// 函数声明被提升</span></span><br><span class="line">    <span class="built_in">console</span>.log( a );  <span class="comment">// 变量声明被提升，所以输出undefined </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;         <span class="comment">// 执行留在原处，赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式不会被提升</span></span><br><span class="line">foo(); <span class="comment">// TypeError，变量提升了，但这时foo的值是undefined，对非函数变量执行函数操作，抛出TypeError错误</span></span><br><span class="line">bar(); <span class="comment">// ReferenceError， 名称标识符在外围作用域中也是不可用的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h3><p>函数会首先被提升，然后才是变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引擎 解释执行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var foo; 重复的变量声明不能覆盖函数声明，因此被无视</span></span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是，重复的函数声明会覆盖前一个:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>在块作用域声明的函数也会被提升到外围作用域</del>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"a"</span> ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"b"</span> ); &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>对于语句var a = 2; JS会将其分成两个语句，第一步在编译阶段声明，第二部在执行阶段赋值。</li>
<li>声明（变量与函数）被“提升”到它们各自的作用域顶部。</li>
<li>函数优于变量，提升后函数声明位于变量声明前，变量重复声明不会覆盖函数声明，但是重复的函数声明会覆盖前一个声明。</li>
<li>声明本身会被提升，但不是赋值，即便是函数表达式的赋值，也不会被提升。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifun.work/2017/04/04/You-don-t-know-JS-Scope-Closures-笔记（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weihome">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌斯怀亚-世界以南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/04/You-don-t-know-JS-Scope-Closures-笔记（三）/" itemprop="url">You don't know JS: Scope & Closures 笔记（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-04T23:16:36+08:00">
                2017-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="函数与块儿作用域"><a href="#函数与块儿作用域" class="headerlink" title="函数与块儿作用域"></a>函数与块儿作用域</h2><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>每个函数都有自己的作用域，在这个作用域内声明的变量属于这个函数，可以使用和重用，而且甚至可以在嵌套的作用域中访问。</p>
<h3 id="最少曝光原则"><a href="#最少曝光原则" class="headerlink" title="最少曝光原则"></a>最少曝光原则</h3><p>把私有细节保持为私有的，只暴露出给应该给外部使用的特性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b和doSomethingElse(..)对任何外界都是不可访问的，而是仅仅由doSomething(..)控制。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line">    b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( (b * <span class="number">3</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<h3 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h3><p>利用函数作用域的访问规则，可以避免两个同名但用处不同的标识符之间发生无意的冲突。冲突经常导致值被意外地覆盖。当使用多个库时，应该在全局创建一个对象作为这个库的“名称空间”，所有要明确暴露出来的功能都被作为属性挂在这个对象（名称空间）上，而不是将它们自身作为顶层词法作用域的标识符。</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><h4 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h4><p>这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;        <span class="comment">// 声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;  <span class="comment">// 表达式</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;)();    <span class="comment">// 表达式</span></span><br></pre></td></tr></table></figure>
<p>函数表达式可以是匿名的，但是函数声明不能省略名称。</p>
<p>匿名函数的缺点：</p>
<ul>
<li>在栈轨迹上匿名函数没有有用的名称可以表示，这使得调试更加困难。</li>
<li>匿名函数为了递归或处理器函数在被触发后想要把自己解除绑定等目的引用它自己，那么就需要很不幸地使用 被废弃的 arguments.callee引用。</li>
<li>一个描述性的名称可以帮助代码自解释。</li>
</ul>
<h4 id="立即调用函数表达式IIFE"><a href="#立即调用函数表达式IIFE" class="headerlink" title="立即调用函数表达式IIFE"></a>立即调用函数表达式IIFE</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">argument</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;)(argument); <span class="comment">// 可以传参</span></span><br></pre></td></tr></table></figure>
<p>UMD–统一模块定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> def </span>)</span>&#123;                  <span class="comment">// 函数作为参数被传入</span></span><br><span class="line">    def( <span class="built_in">window</span> );                      <span class="comment">// 执行被传入的函数，window作为要执行函数的参数传入</span></span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> global </span>)</span>&#123;              <span class="comment">// 定义函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log( global.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="作用域块"><a href="#作用域块" class="headerlink" title="作用域块"></a>作用域块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希望使用块作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是变量实际上将自己划入了外围作用域中（函数或全局）。对于变量i的块儿作用域（如果它是可能的话）将使i仅在for循环内部可用，使得如果在函数的其他地方访问i将导致一个错误。这有助于保证变量不会被糊涂地重用或者难于维护。</p>
<h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>它从对象中创建的作用域仅存在于这个with语句的生命周期中，而不再外围作用域中。</p>
<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h4><p>JavaScript在ES3中明确指出在try/catch的catch子句中声明的变量，是属于catch块儿的块儿作用域的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>(); <span class="comment">// 用非法的操作强制产生一个异常！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( err ); <span class="comment">// 打印'err'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( err ); <span class="comment">// ReferenceError: `err` not found, err仅存在于catch子句中，试着从其他地方引用时会抛出错误。</span></span><br></pre></td></tr></table></figure>
<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>let关键字将变量声明附着在它所在的任何块儿（通常是一个{ .. }）的作用域中。换句话说，let把它的变量声明隐含地留在块儿的作用域内。使用let做出的声明将不会在它们所出现的整个块儿的作用域中提升。如此，直到声明语句为止，声明将不会“存在”于块儿中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError!</span></span><br><span class="line">   <span class="keyword">let</span> bar = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>块儿作用域的另一个有用之处是关于闭包和释放内存的垃圾回收。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做些有趣的事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line"></span><br><span class="line">process( someReallyBigData );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"my_button"</span> );</span><br><span class="line"></span><br><span class="line">btn.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<p>点击事件的处理器回调函数click根本不 需要 someReallyBigData变量。这意味着从理论上讲，在process(..)运行之后，这个消耗巨大内存的数据结构可以被作为垃圾回收。然而，JS引擎很可能（虽然这要看具体实现）将会仍然将这个结构保持一段时间，因为click函数在整个作用域上拥有一个闭包。</p>
<p>块儿作用域可以解决这个问题，使引擎清楚地知道它不必再保持someReallyBigData了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做些有趣的事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行过后，任何定义在这个块中的东西都可以消失了</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line"></span><br><span class="line">    process( someReallyBigData );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"my_button"</span> );</span><br><span class="line"></span><br><span class="line">btn.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<h4 id="let循环"><a href="#let循环" class="headerlink" title="let循环"></a>let循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( i ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>在for循环头部的let不仅将i绑定在for循环体中，而且实际上，它会对每一次循环的 迭代 重新绑定i，确保它被赋予来自上一次循环迭代末尾的值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = j; <span class="comment">// 每次迭代都重新绑定</span></span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>ES6的const也创建一个块儿作用域变量，但是它的值是固定的（常量）。任何改变它的企图都将导致错误。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>函数是JS最常见的作用域单位。在函数内部声明的变量和函数，实质上对任何<b>外围</b>“作用域”都是“隐藏的”。</li>
<li>块儿作用域：变量和函数可以属于任意代码块儿（一般来说，就是任意的{ .. }），而不是仅属于外围的函数。</li>
<li>在ES6中，引入了let关键字（var关键字的表兄弟）允许在任意代码块中声明的变量只存在于块作用域内。</li>
<li>let和var两种机制的互补。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifun.work/2017/04/03/You-don-t-know-JS-Scope-Closures-笔记（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weihome">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌斯怀亚-世界以南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/03/You-don-t-know-JS-Scope-Closures-笔记（二）/" itemprop="url">You don't know JS: Scope & Closures 笔记（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-03T22:50:45+08:00">
                2017-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>作用域是什么？</p>
<h3 id="作用域的工作方式"><a href="#作用域的工作方式" class="headerlink" title="作用域的工作方式"></a>作用域的工作方式</h3><ul>
<li>词法作用域：词法分析时被定义的作用域</li>
<li>动态作用域：调用时确定的作用域</li>
</ul>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法作用域是根据变量、函数、块等在什么地方编写确定其作用域，词法分析过后被确定下来，基本不会改变。</p>
<h3 id="引擎查询标识符"><a href="#引擎查询标识符" class="headerlink" title="引擎查询标识符"></a>引擎查询标识符</h3><p>先从最内部的作用域开始查找，如果没找到，再逐级向上查询。一旦找到第一个匹配，作用域查询就停止了。如果有相同的标识符，内部的标识符屏蔽外部的标识符。函数的词法作用域是由这个函数被声明的位置唯一定义的。词法作用域查询仅仅在处理头等标识符时实施：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>; <span class="comment">// 查询a时词法作用域实施</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">b.a = <span class="number">2</span>; <span class="comment">// 查询b时词法作用域实施，然后对象属性访问规则将会接管a属性的解析。</span></span><br></pre></td></tr></table></figure>
<h3 id="欺骗词法作用域"><a href="#欺骗词法作用域" class="headerlink" title="欺骗词法作用域"></a>欺骗词法作用域</h3><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>接收一个字符串作为参数值，并将这个字符串的内容插入到eval函数的位置，好像这个内容就是当初编写进去的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>( str );  <span class="comment">// str被当作原本就在这个位置， 相当于这行是： var a = 'eval传进去的a';</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 打印的是"eval传进去的a"，全局作用域的a被内部的屏蔽了，如果使用严格模式，全局作用域的a不会被屏蔽</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'全局作用域下的a'</span>; </span><br><span class="line"></span><br><span class="line">foo( <span class="string">"var a = 'eval传进去的a';"</span>);</span><br></pre></td></tr></table></figure>
<p>eval(..)通常被用于执行动态创建的代码，传入的字符串可以是复杂的代码。在非严格模式下，字符串里面的声明会修改eval所在的作用域。</p>
<h4 id="with-（已被废弃）"><a href="#with-（已被废弃）" class="headerlink" title="with （已被废弃）"></a>with （已被废弃）</h4><p>with语句从传递给它的对象中凭空制造了一个全新的词法作用域。</p>
<p>性能影响：如果出现eval 和 with，引擎在编译阶段所做的任何优化都没有意义，那干脆不用优化了，执行时再去做解析标识符等原本应该在编译时做的工作，导致代码运行变慢。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>词法作用域意味着作用域是由编写时函数被声明的位置的决定的。编译器的词法分析阶段确定所有的标识符是在哪里和如何声明的，并在执行期间预测它们将如何被查询。<br>eval和with可以欺骗词法作用域，eval接收字符串将其作为源代码插入所在的作用域，with接收一个对象作为全新的作用域。这两种做法使引擎不在编译阶段进行优化，因为词法作用域可能被动态改变。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifun.work/2017/03/29/You-don-t-know-JS-Scope-Closures-笔记（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weihome">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌斯怀亚-世界以南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/29/You-don-t-know-JS-Scope-Closures-笔记（一）/" itemprop="url">You don't know JS: Scope & Closures 笔记（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-29T22:25:39+08:00">
                2017-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="What-is-Scope-什么是作用域"><a href="#What-is-Scope-什么是作用域" class="headerlink" title="What is Scope? 什么是作用域"></a>What is Scope? 什么是作用域</h2><p>作用域是一套规则，用来规定如何找到存储的变量。俩个重点：存储和访问。</p>
<h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>虽然JS被成为动态语言，但是代码在执行前也要进行编译，编译主要有三个阶段：</p>
<p>比如有var a = 2; 一般的编译会经过一下步骤：</p>
<p>1.Tokenizing/Lexing（分词/词法分析）：将字符串分解成对编程语言有意义的词法单元：var 、 a 、 = 、 2、; 分词和词法分析的差别：词法单元生成器在判断时调用的是有状态的解析规则，称为 词法分析。</p>
<p>2.Parsing（解析/语法分析）：将词法单元数组转换成代表程序语法结构的树。这个树被称为“抽象语法树（Abstract Syntax Tree，AST）”。</p>
<p>3.Code-Generation（代码生成）：将 抽象语法树 转化为可执行的一组机器指令。</p>
<p>JS引擎做的工作复杂得多，而且js的编译一般是在执行前很短的时间内编译的，而不是构建前。JavaScript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至实施重编译）来保证性能最佳。</p>
<h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><ul>
<li>引擎：从头到尾负责整个 JavaScript 程序的编译及执行过程。</li>
<li>编译器：负责语法分析及代码生成等脏活累活。</li>
<li>作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</li>
</ul>
<p>var a = 2; 编译过程：<br>首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p>
<h4 id="引擎对变量的查询：LHS-和-RHS"><a href="#引擎对变量的查询：LHS-和-RHS" class="headerlink" title="引擎对变量的查询：LHS 和 RHS"></a>引擎对变量的查询：LHS 和 RHS</h4><ul>
<li>LHS:赋值操作的目标是谁, 找到要赋值的目标或容器，然后赋值，一般在赋值操作的左侧</li>
<li>RHS:谁是赋值操作的源头, 取变量的值，一般在赋值操作的右侧</li>
</ul>
<p>引擎通过作用域查询变量。</p>
<h4 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h4><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。向上查询，不能向下查询。</p>
<h4 id="变量查询抛出的异常"><a href="#变量查询抛出的异常" class="headerlink" title="变量查询抛出的异常"></a>变量查询抛出的异常</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a + b );   <span class="comment">// 对b进行RHS查询会抛出异常</span></span><br><span class="line">b = a;                  <span class="comment">// 对b进行LHS查询，严格模式抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line">foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<p>第一次对 b 进行 RHS 查询时是无法找到该变量的,这是一个“未声明”的变量，引擎就会抛出 ReferenceError异常。<br>相较之下，LHS 查询下，如果在顶层中也无法找到目标变量，非严格模式下，就会创建该变量；而严格模式禁止自动或隐式地创建全局变量，在严格模式中 LHS 查询失败时，不会创建并返回一个全局变量，引擎抛出ReferenceError 异常。<br>接下来，如果 RHS 查询找到了一个变量，但是尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。<br>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p>
<h4 id="总结-amp-测验"><a href="#总结-amp-测验" class="headerlink" title="总结&amp;测验"></a>总结&amp;测验</h4><ul>
<li>作用域是什么？</li>
<li>LHS查询和RHS查询</li>
<li>var a = 2; 编译步骤：var a ：在其作用域中声明新变量；a = 2：LHS 查询变量 a 并对其进行赋值。</li>
<li>从作用域中查询变量，一直向上查询也没找到，抛出的异常</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<p>3次LHS查询和4次RHS查询分别在哪？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifun.work/2017/03/28/JS中的求值策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weihome">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌斯怀亚-世界以南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/28/JS中的求值策略/" itemprop="url">JS点滴：求值策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-28T20:31:10+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JS函数参数的求值策略"><a href="#JS函数参数的求值策略" class="headerlink" title="JS函数参数的求值策略"></a>JS函数参数的求值策略</h2><p>最近发现对于JS中函数如何传参有一些困惑，便想着从头梳理一遍。</p>
<p>按照之前的理解，原始类型按值传递，对象按引用传递。</p>
<p>在计算机科学里，这个部分叫<em>求值策略(Evaluation Strategy)</em>。它决定变量之间、函数调用时实参和形参之间值是如何传递的。</p>
<h3 id="按值传递-VS-按引用传递"><a href="#按值传递-VS-按引用传递" class="headerlink" title="按值传递 VS 按引用传递"></a>按值传递 VS 按引用传递</h3><p><strong>按值传递(call by value)</strong>是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。<br><strong>按引用传递(call by reference)</strong>时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。</p>
<p>按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的BUG。<br>按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。</p>
<p>一般使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始值类型的传参</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(a);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>这种情况，参数的值是调用者传递的对象值的拷贝(copy of value），函数内部改变参数的值不会影响到该参数在外面的值，一般来说，是重新分配了新内存，该新内存块的值是外部对象的拷贝，并且它的值是用到函数内部的。</p>
<p>如果函数的参数不是原始值而是复杂的结构对象时，将带来很大的性能问题，这时候就不会采用按值传递：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的传参</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 10 obj1改变了</span></span><br></pre></td></tr></table></figure>
<p>说明obj和obj1是同一个对象，obj不是obj1的副本，所以不是按值传递。但这样是否说明JS的对象是按引用传递的呢？我们再看下面的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的传参</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="string">'a'</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">baz(obj2);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.a); <span class="comment">// 1 obj2没有变化</span></span><br></pre></td></tr></table></figure>
<p>如果是按引用传递，修改形参obj的值，应该影响到实参才对。但这里修改obj的值并未影响obj2。因此JS中的对象并不是按引用传递。那么究竟对象的值在JS中如何传递的呢？</p>
<h3 id="按共享传递-call-by-sharing"><a href="#按共享传递-call-by-sharing" class="headerlink" title="按共享传递 call by sharing"></a>按共享传递 call by sharing</h3><p>准确的说，JS中的基本类型按值传递，对象类型按共享传递的(call by sharing)。最早由<code>Barbara Liskov</code>在1974年的GLU语言中提出。该求值策略被用于Python、Java、Ruby、JS等多种语言。</p>
<blockquote>
<p>该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。</p>
</blockquote>
<p>因为传参是引用的副本，所以不能通过修改形参的值，来修改实参的值；虽然引用是副本，但是引用的对象是相同的。它们共享相同的对象，所以修改形参对象的属性值，也会影响到实参的属性值。</p>
<p>比如以上参数是对象的例子，对形参的赋值不会改变实参（因为传递的是引用的副本），但是对形参属性的改变会影响实参（引用的对象相同）。</p>
<h3 id="按共享传递是特殊的按值传递"><a href="#按共享传递是特殊的按值传递" class="headerlink" title="按共享传递是特殊的按值传递"></a>按共享传递是特殊的按值传递</h3><p>按共享传递，修改参数的属性将会影响到外部，而重新赋值将不会影响到外部对象。按共享传递也是按值传递，只不过该值是引用的拷贝（地址副本）。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>对于基本类型，由于它们都是不可变的，按共享传递与按值传递没有任何区别，所以说JS基本类型既符合按值传递，也符合按共享传递。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;        <span class="comment">// 1是number类型，不可变 </span></span><br><span class="line"><span class="keyword">var</span> b = a;        <span class="comment">// 传递特殊的值——引用地址拷贝（a的副本）</span></span><br><span class="line">b = <span class="number">10</span>;            <span class="comment">// b的赋值不会影响a</span></span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>据按共享传递的求值策略，a和b是两个不同的引用(b是a的引用副本)，但引用相同的值。由于这里的基本类型数字1不可变，所以这里说按值传递、按共享传递没有任何区别。</p>
<h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><p>对于对象类型，由于对象是可变的，修改对象本身会影响到共享这个对象的引用和引用副本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(bar === foo); <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">bar.x = <span class="number">10</span>;</span><br><span class="line">bar.y = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log([foo.x, foo.y]); <span class="comment">// [10, 20]</span></span><br></pre></td></tr></table></figure>
<p>而重新赋值分配，绑定是新的地址，而不影响已经先前的绑定 ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar = &#123;<span class="attr">z</span>: <span class="number">1</span>, <span class="attr">q</span>: <span class="number">2</span>&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log([foo.x, foo.y]); <span class="comment">// [10, 20] foo没改变</span></span><br><span class="line"><span class="built_in">console</span>.log([bar.z, bar.q]); <span class="comment">// [1, 2] bar现在引用的是新地址</span></span><br></pre></td></tr></table></figure>
<p>将变量赋值给另外一个变量——是赋值值的引用。因此两个变量引用的是同一个内存地址。下一个赋值却是新地址，是解除与旧对象的地址绑定，然后绑定到新对象的地址上，这就是和按引用传递的最重要区别。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对JS的求值策略有两种解释：</p>
<ul>
<li>JS采取的都是“按值传递”的求值策略, 其中对象类型较为特殊，实际为按值传递了引用(即传递引用的副本，而不是按引用传递引用)。从这个角度，说对象也是按值传递也是有道理的。</li>
<li>引入“按共享传递”的求值策略，它让我们精确的区分按共享传递与经典的按值传递、按引用传递的不同。在这种情形下，可以按传参类型区分：“基本类型按值传递、而对象按共享传递。”</li>
</ul>
<p>虽然关于JS的求值策略有诸多争议和不同版本，但可以认为：JS中基本类型是按值传递的，对象类型是按共享传递的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ifun.work/2017/03/27/对chrome-Provisional-headers-are-shown的追查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weihome">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌斯怀亚-世界以南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/27/对chrome-Provisional-headers-are-shown的追查/" itemprop="url">对chrome Provisional headers are shown的追查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-27T20:28:41+08:00">
                2017-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>最近开发的邮件系统有一个全局的错误拦截，报错后会弹出错误提示，就像这个：</p>
<p><img src="http://onh4i9vxw.bkt.clouddn.com/error-tip.png" alt="error-tip"></p>
<p>前几天做完一个功能，提交上去准备给测试妹子测试了，无聊的时候自己点一点，没想到点出了个问题。是这样的，我向后台调用搜索接口，同样的关键词多次搜索，大部分时候返回正确结果，但是偶然会出现错误提示。虽然一头雾水，但是自己发现的bug不叫bug，别人发现的bug才叫bug，趁没人发现赶紧补上吧~</p>
<p>打开控制台，找一下出错的地方，定位到了network，如下图:</p>
<p><img src="http://onh4i9vxw.bkt.clouddn.com/network-list.png" alt="network-list"></p>
<p>可以看到，输入关键词’a’进行搜索，前几次都是返回正确的结果，最后一次出现了错误了，而关键词’as’也返回了正确结果。此时此刻，我的内心有一句MMP有点想讲，但还是算了，</p>
<p><img src="http://onh4i9vxw.bkt.clouddn.com/bq.jpg" alt=""></p>
<h2 id="追查"><a href="#追查" class="headerlink" title="追查"></a>追查</h2><h3 id="select2插件"><a href="#select2插件" class="headerlink" title="select2插件"></a>select2插件</h3><p>首先可以排除语法的问题，同样的关键词，偶然会出现错误。这个接口是在插件select2中使用的，会是select2的问题么。把这个接口拿到其它地方使用，这个错误具有偶发性，希望它来呢越是不来，我都要以为是select2的锅了。然而，select2表示这个锅他不背…</p>
<p><img src="http://onh4i9vxw.bkt.clouddn.com/err-list2.png" alt="network-list2"></p>
<p>好了，排除掉select2。重新看一下错误的网络请求：</p>
<p><img src="http://onh4i9vxw.bkt.clouddn.com/cancel.png" alt=""></p>
<p>发生错误的请求被取消了！为什么被取消呢，前面和后面的请求都返回了正确的结果。再看一下详细面板，</p>
<p><img src="http://onh4i9vxw.bkt.clouddn.com/error-detail.png" alt="error-detail"></p>
<p>header面板给出了一个提示：</p>
<blockquote>
<p>Provisional headers are shown</p>
</blockquote>
<p>preview和response内容为空，时间线显示的是</p>
<p><img src="http://onh4i9vxw.bkt.clouddn.com/err-timing.png" alt="timing"></p>
<blockquote>
<p>这个请求被停止了</p>
</blockquote>
<p>对于之前没遇到又一时没头绪的问题，找搜索引擎就对了。</p>
<h3 id="chrome-插件"><a href="#chrome-插件" class="headerlink" title="chrome 插件"></a>chrome 插件</h3><p>原来一些chrome插件会屏蔽掉某些网络请求，使之没发出去，比如过滤广告的Adblock等，不过我并没有使用跟网络有关的chrome插件，pass。</p>
<h3 id="浏览器或是系统环境？"><a href="#浏览器或是系统环境？" class="headerlink" title="浏览器或是系统环境？"></a>浏览器或是系统环境？</h3><p>经过测试，edge也有这种情况，换台电脑吧，嗯，一样的。</p>
<h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><p>到这时候已经有点想甩锅了，说不定就是后台响应请求速度太慢的问题。嗯，我这就去找后台…</p>
<h3 id="继续求助搜索引擎"><a href="#继续求助搜索引擎" class="headerlink" title="继续求助搜索引擎"></a>继续求助搜索引擎</h3><p>因为拿不出证据被后台大叔怼回来的我，只好继续上网搜索了，stackoverflow上面倒有一些相关问题，不过他们是请求被Pending了很久，从请求的时间线来看，体现在Stalled的时间长达几十秒，比如<a href="http://stackoverflow.com/questions/14821725/ajax-request-over-https-hangs-for-40-seconds-in-chrome-only" target="_blank" rel="noopener">这个</a></p>
<p>可是，可是我这个错误stalled的时间只有几十毫秒啊…<br><img src="http://onh4i9vxw.bkt.clouddn.com/bq2.jpg" alt="ganga"></p>
<p>虽然没找到跟我这个问题相似的情况，不过倒是收获了慢慢的干货，比如这一篇<a href="http://fex.baidu.com/blog/2015/01/chrome-stalled-problem-resolving-process/" target="_blank" rel="noopener">关于请求被挂起页面加载缓慢问题的追查</a> 这位百度FEX的前辈好厉害啊，多多向他学习！</p>
<h3 id="撸起袖子就是干"><a href="#撸起袖子就是干" class="headerlink" title="撸起袖子就是干"></a>撸起袖子就是干</h3><p>回到正题，网络上找不到相似的问题，只好自己动手，丰衣足食了。听他们讲，chrome的net-internals可以查看具体的网络请求细节，嗯，先在地址栏输入chrome://net-internals，然后我内心是这样的：这都是什么啊</p>
<p><img src="http://onh4i9vxw.bkt.clouddn.com/yilian.jpg" alt="yilian"></p>
<p>么事么事，我先去找一下net-internals的说明，等我回来再战。 </p>
<h3 id="net-internals"><a href="#net-internals" class="headerlink" title="net-internals"></a>net-internals</h3><p>切换到event，点开一个请求，可以看到类似的信息:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">36499: URL_REQUEST</span><br><span class="line">https://angular.cn/</span><br><span class="line">Start Time: 2017-03-27 23:03:46.769</span><br><span class="line"></span><br><span class="line">t=56812 [st=  0] +REQUEST_ALIVE  [dt=167]</span><br><span class="line">t=56812 [st=  0]    DELEGATE_INFO  [dt=0]  <span class="comment"># 第一部分的工作开始</span></span><br><span class="line">                    --&gt; delegate_info = <span class="string">"NavigationResourceThrottle"</span></span><br><span class="line">t=56812 [st=  0]    URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=56813 [st=  1]    URL_REQUEST_START_JOB  [dt=0]</span><br><span class="line">                    --&gt; load_flags = 37120 (MAIN_FRAME_DEPRECATED | MAYBE_USER_GESTURE | VERIFY_EV_CERT)</span><br><span class="line">                    --&gt; method = <span class="string">"GET"</span></span><br><span class="line">                    --&gt; priority = <span class="string">"HIGHEST"</span></span><br><span class="line">                    --&gt; url = <span class="string">"https://angular.cn/"</span></span><br><span class="line">t=56813 [st=  1]   +URL_REQUEST_START_JOB  [dt=163]</span><br><span class="line">                    --&gt; load_flags = 37120 (MAIN_FRAME_DEPRECATED | MAYBE_USER_GESTURE | VERIFY_EV_CERT)</span><br><span class="line">                    --&gt; method = <span class="string">"GET"</span></span><br><span class="line">                    --&gt; priority = <span class="string">"HIGHEST"</span></span><br><span class="line">                    --&gt; url = <span class="string">"https://angular.cn/"</span></span><br><span class="line">t=56813 [st=  1]      URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=56813 [st=  1]      HTTP_CACHE_GET_BACKEND  [dt=0]</span><br><span class="line">t=56813 [st=  1]      HTTP_CACHE_OPEN_ENTRY  [dt=0]</span><br><span class="line">                      --&gt; net_error = -2 (ERR_FAILED)</span><br><span class="line">t=56813 [st=  1]      HTTP_CACHE_CREATE_ENTRY  [dt=0]</span><br><span class="line">t=56813 [st=  1]      HTTP_CACHE_ADD_TO_ENTRY  [dt=0]</span><br><span class="line">t=56813 [st=  1]     +HTTP_STREAM_REQUEST  [dt=1]  <span class="comment"># 第二部分开始</span></span><br><span class="line">t=56813 [st=  1]        HTTP_STREAM_REQUEST_STARTED_JOB</span><br><span class="line">                        --&gt; source_dependency = 36502 (HTTP_STREAM_JOB)</span><br><span class="line">t=56814 [st=  2]        HTTP_STREAM_REQUEST_BOUND_TO_JOB</span><br><span class="line">                        --&gt; source_dependency = 36502 (HTTP_STREAM_JOB)</span><br><span class="line">t=56814 [st=  2]     -HTTP_STREAM_REQUEST</span><br><span class="line">t=56814 [st=  2]     +HTTP_TRANSACTION_SEND_REQUEST  [dt=0] <span class="comment"># 发送请求头</span></span><br><span class="line">t=56814 [st=  2]        HTTP_TRANSACTION_HTTP2_SEND_REQUEST_HEADERS</span><br><span class="line">                        --&gt; :authority: angular.cn</span><br><span class="line">                            :method: GET</span><br><span class="line">                            :path: /</span><br><span class="line">                            :scheme: https</span><br><span class="line">                            accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">                            accept-encoding: gzip, deflate, sdch, br</span><br><span class="line">                            accept-language: zh-CN,zh;q=0.8</span><br><span class="line">                            upgrade-insecure-requests: 1</span><br><span class="line">                            user-agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.3 Safari/537.36</span><br><span class="line">t=56814 [st=  2]     -HTTP_TRANSACTION_SEND_REQUEST</span><br><span class="line">t=56814 [st=  2]     +HTTP_TRANSACTION_READ_HEADERS  [dt=160] <span class="comment"># 第三部分 读取响应头</span></span><br><span class="line">t=56974 [st=162]        HTTP_TRANSACTION_READ_RESPONSE_HEADERS</span><br><span class="line">                        --&gt; HTTP/1.1 200</span><br><span class="line">                            status: 200</span><br><span class="line">                            server: Tengine</span><br><span class="line">                            content-type: text/html</span><br><span class="line">                            content-length: 6069</span><br><span class="line">                            date: Mon, 27 Mar 2017 14:57:02 GMT</span><br><span class="line">                            last-modified: Tue, 14 Mar 2017 06:48:21 GMT</span><br><span class="line">                            etag: <span class="string">"58c79235-426e"</span></span><br><span class="line">                            content-encoding: gzip</span><br><span class="line">                            via: cache4.l2et15[98,200-0,H], cache3.l2et15[99,0], kunlun9.cn141[152,200-0,M], kunlun4.cn141[152,0]</span><br><span class="line">                            age: 0</span><br><span class="line">                            x-cache: MISS TCP_MISS dirn:2:87827485</span><br><span class="line">                            x-swift-savetime: Mon, 27 Mar 2017 14:57:02 GMT</span><br><span class="line">                            x-swift-cachetime: 3600</span><br><span class="line">                            timing-allow-origin: *</span><br><span class="line">                            eagleid: 7005fb0414906266225666270e</span><br><span class="line">t=56974 [st=162]     -HTTP_TRANSACTION_READ_HEADERS</span><br><span class="line">t=56975 [st=163]     +HTTP_CACHE_WRITE_INFO  [dt=0] <span class="comment"># 页面缓存处理</span></span><br><span class="line">t=56975 [st=163]        HTTP2_STREAM_UPDATE_RECV_WINDOW</span><br><span class="line">                        --&gt; delta = -1073</span><br><span class="line">                        --&gt; stream_id = 1</span><br><span class="line">                        --&gt; window_size = 6290383</span><br><span class="line">t=56975 [st=163]     -HTTP_CACHE_WRITE_INFO</span><br><span class="line">t=56975 [st=163]      HTTP_CACHE_WRITE_DATA  [dt=0]</span><br><span class="line">t=56975 [st=163]      HTTP_CACHE_WRITE_INFO  [dt=1]</span><br><span class="line">t=56976 [st=164]      URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=56976 [st=164]      URL_REQUEST_FILTERS_SET</span><br><span class="line">                      --&gt; filters = <span class="string">"GZIP"</span></span><br><span class="line">t=56976 [st=164]   -URL_REQUEST_START_JOB</span><br><span class="line">t=56976 [st=164]   +URL_REQUEST_DELEGATE  [dt=2]</span><br><span class="line">t=56976 [st=164]     +DELEGATE_INFO  [dt=1]</span><br><span class="line">                      --&gt; delegate_info = <span class="string">"NavigationResourceThrottle"</span></span><br><span class="line">t=56977 [st=165]        HTTP2_STREAM_UPDATE_RECV_WINDOW</span><br><span class="line">                        --&gt; delta = -1847</span><br><span class="line">                        --&gt; stream_id = 1</span><br><span class="line">                        --&gt; window_size = 6288536</span><br><span class="line">t=56977 [st=165]        HTTP2_STREAM_UPDATE_RECV_WINDOW</span><br><span class="line">                        --&gt; delta = -3149</span><br><span class="line">                        --&gt; stream_id = 1</span><br><span class="line">                        --&gt; window_size = 6285387</span><br><span class="line">t=56977 [st=165]     -DELEGATE_INFO</span><br><span class="line">t=56978 [st=166]   -URL_REQUEST_DELEGATE</span><br><span class="line">t=56978 [st=166]    HTTP_TRANSACTION_READ_BODY  [dt=0] </span><br><span class="line">t=56978 [st=166]    HTTP_CACHE_WRITE_DATA  [dt=0]</span><br><span class="line">t=56978 [st=166]    URL_REQUEST_JOB_BYTES_READ</span><br><span class="line">                    --&gt; byte_count = 6069</span><br><span class="line">t=56978 [st=166]    URL_REQUEST_JOB_FILTERED_BYTES_READ</span><br><span class="line">                    --&gt; byte_count = 17006</span><br><span class="line">t=56978 [st=166]    HTTP_TRANSACTION_READ_BODY  [dt=0]</span><br><span class="line">t=56978 [st=166]    HTTP_CACHE_WRITE_DATA  [dt=0]</span><br><span class="line">t=56979 [st=167] -REQUEST_ALIVE</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>日志第一列为时间线，自请求发起时算。第二列为每步操作所逝去的时间，时间差的概念，与第三列里面的dt不同，它会积累前面的耗时。第三列为具体的事件，以及相应事件的耗时dt，此耗时为绝对耗时。+号对应事件开始，-号对应事件结束，也就是说他们必然成对出现。住里是展开后更加详细的子事件。直到不能再细分。</p>
</blockquote>
<p>可以看到，浏览器主要做了以下的工作：</p>
<ol>
<li>拉取浏览器cache，判断是否需要更新，如果不需要更新则从缓存获取内容直接渲染。判断是否更新的主要依据有：Expires时间、cache设置，浏览器的设置。浏览器拉取缓存的这部分工作主要体现在cache相关的event上</li>
<li>发送页面header请求 </li>
<li>接受响应头信息，接收完header后，浏览器得到了返回的请求类型（200、304……）、服务器资源是否有更新（如果没有更新直接从cache获取缓存渲染）等信息</li>
<li>接收完了页面内容，如果页面需要进行缓存则将页面缓存起来，同时对页面进行解码（包括gzip解压等。根据返回的数据类型（html类型、图片类型、声音…）进行页面渲染</li>
</ol>
<p>我们主要关注两部分，</p>
<ul>
<li>发送请求头 <code>+HTTP_TRANSACTION_SEND_REQUEST  [dt=0]</code></li>
<li>读取响应头 <code>+HTTP_TRANSACTION_READ_HEADERS  [dt=160]</code><br>这是正常的情况下，没有什么问题。并且日志里可以清晰地看到发送的请求头是什么，然后解析出来的响应头是什么。这跟在网络面板看到的是一致的。</li>
</ul>
<h3 id="分析日志"><a href="#分析日志" class="headerlink" title="分析日志"></a>分析日志</h3><p>再来看错误请求的日志详情：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">19208: URL_REQUEST</span><br><span class="line">http://127.0.0.1:8080/api/mail/contacts/search?condition=a</span><br><span class="line">Start Time: 2017-03-27 15:41:57.122</span><br><span class="line"></span><br><span class="line">t=273378 [st= 0] +REQUEST_ALIVE  [dt=38]</span><br><span class="line">t=273378 [st= 0]    URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=273378 [st= 0]   +URL_REQUEST_START_JOB  [dt=37]</span><br><span class="line">                    --&gt; load_flags = 33026 (BYPASS_CACHE | MAYBE_USER_GESTURE | VERIFY_EV_CERT)</span><br><span class="line">                    --&gt; method = <span class="string">"GET"</span></span><br><span class="line">                    --&gt; priority = <span class="string">"MEDIUM"</span></span><br><span class="line">                    --&gt; url = <span class="string">"http://127.0.0.1:8080/api/mail/contacts/search?condition=a"</span></span><br><span class="line">t=273378 [st= 0]      URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=273378 [st= 0]      HTTP_CACHE_GET_BACKEND  [dt=0]</span><br><span class="line">t=273378 [st= 0]      HTTP_CACHE_DOOM_ENTRY  [dt=0]</span><br><span class="line">                      --&gt; net_error = -2 (ERR_FAILED)</span><br><span class="line">t=273378 [st= 0]      HTTP_CACHE_CREATE_ENTRY  [dt=0]</span><br><span class="line">t=273378 [st= 0]      HTTP_CACHE_ADD_TO_ENTRY  [dt=0]</span><br><span class="line">t=273378 [st= 0]     +HTTP_STREAM_REQUEST  [dt=0]</span><br><span class="line">t=273378 [st= 0]        HTTP_STREAM_REQUEST_STARTED_JOB</span><br><span class="line">                        --&gt; source_dependency = 19211 (HTTP_STREAM_JOB)</span><br><span class="line">t=273378 [st= 0]        HTTP_STREAM_REQUEST_BOUND_TO_JOB</span><br><span class="line">                        --&gt; source_dependency = 19211 (HTTP_STREAM_JOB)</span><br><span class="line">t=273378 [st= 0]     -HTTP_STREAM_REQUEST</span><br><span class="line">t=273378 [st= 0]     +HTTP_TRANSACTION_SEND_REQUEST  [dt=0]                       <span class="comment"># 发送请求头</span></span><br><span class="line">t=273378 [st= 0]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS</span><br><span class="line">                        --&gt; GET /api/mail/contacts/search?condition=a HTTP/1.1</span><br><span class="line">                            Host: 127.0.0.1:8080</span><br><span class="line">                            Connection: keep-alive</span><br><span class="line">                            Pragma: no-cache</span><br><span class="line">                            Cache-Control: no-cache</span><br><span class="line">                            Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">                            X-Requested-With: XMLHttpRequest</span><br><span class="line">                            User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36</span><br><span class="line">                            Referer: http://127.0.0.1:8080/pages/mail/mail.html</span><br><span class="line">                            Accept-Encoding: gzip, deflate, sdch, br</span><br><span class="line">                            Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class="line">                            Cookie: [93 bytes were stripped]</span><br><span class="line">t=273378 [st= 0]     -HTTP_TRANSACTION_SEND_REQUEST                               </span><br><span class="line">t=273378 [st= 0]     +HTTP_TRANSACTION_READ_HEADERS  [dt=37]                      <span class="comment"># 读取请求头</span></span><br><span class="line">t=273378 [st= 0]        HTTP_STREAM_PARSER_READ_HEADERS  [dt=37]</span><br><span class="line">t=273415 [st=37]        HTTP_TRANSACTION_READ_RESPONSE_HEADERS</span><br><span class="line">                        --&gt; HTTP/1.1 200</span><br><span class="line">                            X-Content-Type-Options: nosniff</span><br><span class="line">                            X-XSS-Protection: 1; mode=block</span><br><span class="line">                            Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">                            Pragma: no-cache</span><br><span class="line">                            Expires: 0</span><br><span class="line">                            Content-Type: application/json;charset=UTF-8</span><br><span class="line">                            Transfer-Encoding: chunked</span><br><span class="line">                            Date: Mon, 27 Mar 2017 07:41:56 GMT</span><br><span class="line">t=273415 [st=37]     -HTTP_TRANSACTION_READ_HEADERS</span><br><span class="line">t=273415 [st=37]      HTTP_CACHE_WRITE_INFO  [dt=0]                             <span class="comment"># 接受后的处理</span></span><br><span class="line">t=273415 [st=37]      URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=273415 [st=37]   -URL_REQUEST_START_JOB</span><br><span class="line">t=273415 [st=37]    URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=273415 [st=37]    HTTP_TRANSACTION_READ_BODY  [dt=0]</span><br><span class="line">t=273415 [st=37]    URL_REQUEST_JOB_BYTES_READ</span><br><span class="line">                    --&gt; byte_count = 2283</span><br><span class="line">t=273415 [st=37]    HTTP_TRANSACTION_READ_BODY  [dt=0]</span><br><span class="line">t=273416 [st=38] -REQUEST_ALIVE</span><br></pre></td></tr></table></figure>
<hr>
<p>咦，好像并没有错啊，难道我导出时导错了？然而验证之后这就是错误请求的日志，我能怎么办，我也很绝望啊</p>
<p><img src="http://onh4i9vxw.bkt.clouddn.com/swkl.jpg" alt=""></p>
<p>嗯，这很酸爽。我还是再去问问度娘和谷哥吧。</p>
<h3 id="新的希望"><a href="#新的希望" class="headerlink" title="新的希望"></a>新的希望</h3><p>度娘告诉我，浏览器对于同一域名的请求是有数量限制的。</p>
<p>那会不会是请求数量太多了被挂起了？这时候我想起了一直被忽略的，出现错误后还能正常返回的请求，去看一下出错后正常返回的请求日志：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 正常请求的日志</span></span><br><span class="line">19212: URL_REQUEST</span><br><span class="line">http://127.0.0.1:8080/api/mail/contacts/search?condition=as</span><br><span class="line">Start Time: 2017-03-27 15:41:57.171</span><br><span class="line"></span><br><span class="line">t=273427 [st= 0] +REQUEST_ALIVE  [dt=31]</span><br><span class="line">t=273427 [st= 0]    URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=273427 [st= 0]   +URL_REQUEST_START_JOB  [dt=30]</span><br><span class="line">                    --&gt; load_flags = 33026 (BYPASS_CACHE | MAYBE_USER_GESTURE | VERIFY_EV_CERT)</span><br><span class="line">                    --&gt; method = <span class="string">"GET"</span></span><br><span class="line">                    --&gt; priority = <span class="string">"MEDIUM"</span></span><br><span class="line">                    --&gt; url = <span class="string">"http://127.0.0.1:8080/api/mail/contacts/search?condition=as"</span></span><br><span class="line">t=273427 [st= 0]      URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=273427 [st= 0]      HTTP_CACHE_GET_BACKEND  [dt=0]</span><br><span class="line">t=273427 [st= 0]      HTTP_CACHE_DOOM_ENTRY  [dt=0]</span><br><span class="line">                      --&gt; net_error = -2 (ERR_FAILED)</span><br><span class="line">t=273427 [st= 0]      HTTP_CACHE_CREATE_ENTRY  [dt=0]</span><br><span class="line">t=273427 [st= 0]      HTTP_CACHE_ADD_TO_ENTRY  [dt=0]</span><br><span class="line">t=273427 [st= 0]     +HTTP_STREAM_REQUEST  [dt=0]</span><br><span class="line">t=273427 [st= 0]        HTTP_STREAM_REQUEST_STARTED_JOB</span><br><span class="line">                        --&gt; source_dependency = 19215 (HTTP_STREAM_JOB)</span><br><span class="line">t=273427 [st= 0]        HTTP_STREAM_REQUEST_BOUND_TO_JOB</span><br><span class="line">                        --&gt; source_dependency = 19215 (HTTP_STREAM_JOB)</span><br><span class="line">t=273427 [st= 0]     -HTTP_STREAM_REQUEST</span><br><span class="line">t=273428 [st= 1]     +HTTP_TRANSACTION_SEND_REQUEST  [dt=0]</span><br><span class="line">t=273428 [st= 1]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS</span><br><span class="line">                        --&gt; GET /api/mail/contacts/search?condition=as HTTP/1.1</span><br><span class="line">                            Host: 127.0.0.1:8080</span><br><span class="line">                            Connection: keep-alive</span><br><span class="line">                            Pragma: no-cache</span><br><span class="line">                            Cache-Control: no-cache</span><br><span class="line">                            Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">                            X-Requested-With: XMLHttpRequest</span><br><span class="line">                            User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36</span><br><span class="line">                            Referer: http://127.0.0.1:8080/pages/mail/mail.html</span><br><span class="line">                            Accept-Encoding: gzip, deflate, sdch, br</span><br><span class="line">                            Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class="line">                            Cookie: [93 bytes were stripped]</span><br><span class="line">t=273428 [st= 1]     -HTTP_TRANSACTION_SEND_REQUEST</span><br><span class="line">t=273428 [st= 1]     +HTTP_TRANSACTION_READ_HEADERS  [dt=29]     <span class="comment"># 从发出到接受，花费29毫秒，少于上一个请求的37毫秒</span></span><br><span class="line">t=273428 [st= 1]        HTTP_STREAM_PARSER_READ_HEADERS  [dt=29]</span><br><span class="line">t=273457 [st=30]        HTTP_TRANSACTION_READ_RESPONSE_HEADERS</span><br><span class="line">                        --&gt; HTTP/1.1 200</span><br><span class="line">                            X-Content-Type-Options: nosniff</span><br><span class="line">                            X-XSS-Protection: 1; mode=block</span><br><span class="line">                            Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span><br><span class="line">                            Pragma: no-cache</span><br><span class="line">                            Expires: 0</span><br><span class="line">                            Content-Type: application/json;charset=UTF-8</span><br><span class="line">                            Transfer-Encoding: chunked</span><br><span class="line">                            Date: Mon, 27 Mar 2017 07:41:56 GMT   <span class="comment"># 这个时间跟上一个请求是一样的！</span></span><br><span class="line">t=273457 [st=30]     -HTTP_TRANSACTION_READ_HEADERS</span><br><span class="line">t=273457 [st=30]      HTTP_CACHE_WRITE_INFO  [dt=0]</span><br><span class="line">t=273457 [st=30]      URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=273457 [st=30]   -URL_REQUEST_START_JOB</span><br><span class="line">t=273457 [st=30]    URL_REQUEST_DELEGATE  [dt=0]</span><br><span class="line">t=273457 [st=30]    HTTP_TRANSACTION_READ_BODY  [dt=1]</span><br><span class="line">t=273458 [st=31]    URL_REQUEST_JOB_BYTES_READ</span><br><span class="line">                    --&gt; byte_count = 3</span><br><span class="line">t=273458 [st=31]    HTTP_TRANSACTION_READ_BODY  [dt=0]</span><br><span class="line">t=273458 [st=31] -REQUEST_ALIVE</span><br></pre></td></tr></table></figure>
<hr>
<p>仔细看，发现了两次响应头返回的时间是一样的！可是为什么是7点啊，这个时间代表的是什么？事以至此，虽然还有些地方不是很明白，不过可以推测不外乎两个原因：</p>
<ul>
<li>后一个请求返回的结果时间戳跟前一个是一样的，浏览器保留了后一个请求返回的结果，丢弃了前一个请求</li>
<li>后一个请求返回结果的时间早于前一个请求，浏览器接受了后一个请求的结果，丢弃了前一个请求</li>
</ul>
<p>不管怎么看，前一个请求都是被浏览器丢弃了，突然觉得它有点可怜，心疼。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在全局错误拦截方法里，打了个断点。再次重复机械的操作，控制台终于有反应了。赶紧瞧瞧，看到“abort”, 果然是被抛弃了…</p>
<p>早知道我打个断点就好了啊，就不用大费周章了，可是我怎么觉得这波不亏呢</p>
<p>既然是请求被丢弃了，后面又有新的请求返回了正确的结果，那么用户对于这类错误其实没必要感知。果断找技术总监确认一下，讨论过后决定屏蔽掉这类错误。</p>
<h2 id="陈词总结"><a href="#陈词总结" class="headerlink" title="陈词总结"></a>陈词总结</h2><p>可能引起chrome网络请求出现 “provisional headers are shown” 提示的原总结起来有以下几点：</p>
<ul>
<li>chrome网络相关的插件，比如广告过滤插件</li>
<li>后端迟迟不返回结果，造成stalled时间过长</li>
<li>浏览器对于同一域名的请求有个数限制</li>
<li>对同一目标的先后多个请求，后面的请求返回在前导致前面的请求被丢弃</li>
</ul>
<h2 id="疑点"><a href="#疑点" class="headerlink" title="疑点"></a>疑点</h2><p>关于第四点，从网络日志来看，前一个请求发送请求头的时间是早于后一个请求的，但是前一个请求被“cancel”，也就是被取消了，这个请求并没有发出去，而后面的请求已经返回了。所以说日志里发送请求头的时间不代表浏览器真正发送请求的时间？现在没法给出更合理的解释，先记录在案吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">weihome</p>
              <p class="site-description motion-element" itemprop="description">博客 前端 前端开发</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">weihome</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
